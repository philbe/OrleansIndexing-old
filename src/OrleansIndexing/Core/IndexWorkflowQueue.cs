using Orleans.Concurrency;
using Orleans.Core;
using Orleans.Runtime;
using Orleans.Storage;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace Orleans.Indexing
{
    /// <summary>
    /// To minimize the number of RPCs, we process index updates for each grain
    /// on the silo where the grain is active. To do this processing, each silo
    /// has one or more IndexWorkflowQueue system-targets for each grain class,
    /// up to the number of hardware threads. A system-target is a grain that
    /// belongs to a specific silo.
    /// + Each of these system-targets has a queue of workflowRecords, which describe
    ///   updates that must be propagated to indexes.Each workflowRecord contains
    ///   the following information:
    ///    - workflowID: grainID + a sequence number
    ///    - memberUpdates: the updated values of indexed fields
    ///  
    ///   Ordinarily, these workflowRecords are for grains that are active on
    ///   IndexWorkflowQueue's silo. (This may not be true for short periods when
    ///   a grain migrates to another silo or after the silo recovers from failure).
    /// 
    /// + The IndexWorkflowQueue grain Q has a dictionary updatesOnWait is an
    ///   in-memory dictionary that maps each grain G to the workflowRecords for G
    ///   that are waiting for be updated
    /// </summary>
    [Reentrant]
    internal class IndexWorkflowQueue : SystemTarget, IIndexWorkflowQueue
    {
        //the persistent state of IndexWorkflowQueue, including:
        // - doubly linked list of workflowRecordds
        // - the identity of the IndexWorkflowQueue system target
        protected IndexWorkflowQueueState State;

        //the tail of workflowRecords doubly linked list
        internal IndexWorkflowRecordNode _workflowRecordsTail;

        //the storage provider for index work-flow queue
        private IStorageProvider __storageProvider;
        private IStorageProvider StorageProvider { get { return __storageProvider == null ? InitStorageProvider() : __storageProvider; } }

        private int _queueSeqNum;
        private Type _iGrainType;

        private bool _isDefinedAsFaultTolerantGrain;
        private sbyte __hasAnyIIndex;
        private bool HasAnyIIndex { get { return __hasAnyIIndex == 0 ? InitHasAnyIIndex() : __hasAnyIIndex > 0; } }
        private bool IsFaultTolerant { get { return _isDefinedAsFaultTolerantGrain && HasAnyIIndex; } }

        private IIndexWorkflowQueueHandler __handler;
        private IIndexWorkflowQueueHandler Handler { get { return __handler == null ? InitWorkflowQueueHandler() : __handler; } }

        private bool _isHandlerWorkerIdle;

        /// <summary>
        /// This lock is used to queue all the writes to the storage
        /// and do them in a single batch, i.e., group commit
        /// 
        /// Works hand-in-hand with pendingWriteRequests and writeRequestIdGen.
        /// </summary>
        private AsyncLock _writeLock;

        /// <summary>
        /// Creates a unique ID for each write request to the storage.
        /// 
        /// The values generated by this ID generator are used in pendingWriteRequests
        /// </summary>
        private int _writeRequestIdGen;

        /// <summary>
        /// All the write requests that are waiting behind write_lock are accumulated
        /// in this data structure, and all of them will be done at once.
        /// </summary>
        private HashSet<int> _pendingWriteRequests;

        public const int BATCH_SIZE = int.MaxValue;

        public static int NUM_AVAILABLE_INDEX_WORKFLOW_QUEUES { get { return Environment.ProcessorCount; } }

        internal IndexWorkflowQueue(Type grainInterfaceType, int queueSequenceNumber, SiloAddress silo, bool isDefinedAsFaultTolerantGrain) : base(CreateIndexWorkflowQueueGrainId(grainInterfaceType, queueSequenceNumber), silo)
        {
            State = new IndexWorkflowQueueState(GrainId, silo);
            _iGrainType = grainInterfaceType;
            _queueSeqNum = queueSequenceNumber;

            _workflowRecordsTail = null;
            __storageProvider = null;
            __handler = null;
            _isHandlerWorkerIdle = true;

            _isDefinedAsFaultTolerantGrain = isDefinedAsFaultTolerantGrain;
            __hasAnyIIndex = 0;

            _writeLock = new AsyncLock();
            _writeRequestIdGen = 0;
            _pendingWriteRequests = new HashSet<int>();
        }

        public static GrainId CreateIndexWorkflowQueueGrainId(Type grainInterfaceType, int queueSeqNum)
        {
            return GrainId.GetSystemTargetGrainId(Constants.INDEX_WORKFLOW_QUEUE_SYSTEM_TARGET_TYPE_CODE,
                                                  CreateIndexWorkflowQueuePrimaryKey(grainInterfaceType, queueSeqNum));
        }

        public static string CreateIndexWorkflowQueuePrimaryKey(Type grainInterfaceType, int queueSeqNum)
        {
            return TypeUtils.GetFullName(grainInterfaceType) + "-" + queueSeqNum;
        }

        public static GrainId GetIndexWorkflowQueueGrainIdFromGrainHashCode<TGrain>(int grainHashCode) where TGrain : IIndexableGrain
        {
            return GrainId.GetSystemTargetGrainId(Constants.INDEX_WORKFLOW_QUEUE_SYSTEM_TARGET_TYPE_CODE,
                                                  CreateIndexWorkflowQueuePrimaryKey(typeof(TGrain), StorageProviderUtils.PositiveHash(grainHashCode, NUM_AVAILABLE_INDEX_WORKFLOW_QUEUES)));
        }

        private IIndexWorkflowQueueHandler InitWorkflowQueueHandler()
        {
            return __handler = InsideRuntimeClient.Current.InternalGrainFactory.GetSystemTarget<IIndexWorkflowQueueHandler>(IndexWorkflowQueueHandler.CreateIndexWorkflowQueueHandlerGrainId(_iGrainType, _queueSeqNum), Silo);
        }

        public Task AddToQueue(Immutable<IndexWorkflowRecord> workflow)
        {
            IndexWorkflowRecord newWorkflow = workflow.Value;
            IndexWorkflowRecordNode newWorkflowNode = new IndexWorkflowRecordNode(newWorkflow);
            if (_workflowRecordsTail == null) //if the list is empty
            {
                _workflowRecordsTail = newWorkflowNode;
                State.State.WorkflowRecordsHead = newWorkflowNode;
            }
            else // otherwise append to the end of the list
            {
                _workflowRecordsTail.Append(newWorkflowNode, ref _workflowRecordsTail);
            }

            if (IsFaultTolerant)
            {
                return Task.WhenAll(PersistState(), InitiateWorkerThread());
            }
            else
            {
                return InitiateWorkerThread();
            }
        }

        private async Task InitiateWorkerThread()
        {
            if(_isHandlerWorkerIdle)
            {
                IndexWorkflowRecordNode punctuatedHead = AddPuctuationAt(BATCH_SIZE);
                _isHandlerWorkerIdle = !await Handler.HandleWorkflowsUntilPunctuation(punctuatedHead.AsImmutable());
            }
        }

        private IndexWorkflowRecordNode AddPuctuationAt(int batchSize)
        {
            if (_workflowRecordsTail == null) return null;

            var punctutationHead = State.State.WorkflowRecordsHead;
            if (punctutationHead.IsPunctuation()) return null;

            if (batchSize == int.MaxValue)
            {
                var punctuation = _workflowRecordsTail.AppendPunctuation(ref _workflowRecordsTail);
                if (punctuation == null)
                    return null;
                else
                    return punctutationHead;
            }
            var punctutationLoc = punctutationHead;

            int i = 1;
            while(i < batchSize && punctutationLoc.Next != null)
            {
                punctutationLoc = punctutationLoc.Next;
                ++i;
            }
            punctutationLoc.AppendPunctuation(ref _workflowRecordsTail);
            return punctutationHead;
        }

        //public async Task RemoveFromQueue(IndexWorkflowRecordNode workflowsHead, int numWorkflows)
        //{
        //    if (numWorkflows == 0) return;

        //    IndexWorkflowRecordNode tmpNext;
        //    int i = 0;
        //    do
        //    {
        //        tmpNext = workflowsHead.Next;
        //        if (i == 0 || i == (numWorkflows - 1))
        //        {
        //            workflowsHead.Remove(ref workflowRecordsTail, ref State.State.WorkflowRecordsHead);
        //        }
        //        else
        //        {
        //            workflowsHead.Clean();
        //        }
        //        workflowsHead = tmpNext;
        //    } while (++i < numWorkflows);

        //    await PersistState();
        //}

        private void RemoveFromQueueUntilPunctuation(IndexWorkflowRecordNode from)
        {
            IndexWorkflowRecordNode tmp = from.Next;
            while (tmp != null && !tmp.IsPunctuation())
            {
                tmp.Clean();
            }
            if (tmp == null) from.Remove(ref _workflowRecordsTail, ref State.State.WorkflowRecordsHead);
            else
            {
                from.Next = tmp;
                tmp.Prev = from;
                from.Remove(ref _workflowRecordsTail, ref State.State.WorkflowRecordsHead);
                tmp.Remove(ref _workflowRecordsTail, ref State.State.WorkflowRecordsHead);
            }
        }

        //public Task RemoveFromQueueAndPersist(IndexWorkflowRecordNode from, IndexWorkflowRecordNode to)
        //{
        //    RemoveFromQueue(from, to);
        //    return PersistState();
        //}

        private async Task PersistState()
        {
            //create a write-request ID, which is used for group commit
            int writeRequestId = ++_writeRequestIdGen;

            //add the write-request ID to the pending write requests
            _pendingWriteRequests.Add(writeRequestId);

            //wait before any previous write is done
            using (await _writeLock.LockAsync())
            {
                //if the write request was not already handled
                //by a previous group write attempt
                if (_pendingWriteRequests.Contains(writeRequestId))
                {
                    //clear all pending write requests, as this attempt will do them all.
                    _pendingWriteRequests.Clear();
                    //write the state back to the storage
                    await StorageProvider.WriteStateAsync("Orleans.Indexing.IndexWorkflowQueue-" + TypeUtils.GetFullName(_iGrainType), this.AsWeaklyTypedReference(), State);
                }
                //else
                //{
                //    Nothing! It's already been done by a previous worker.
                //}
            }
        }

        public Task<Immutable<IndexWorkflowRecordNode>> GiveMoreWorkflowsOrSetAsIdle()
        {
            RemoveFromQueueUntilPunctuation(State.State.WorkflowRecordsHead);
            if (IsFaultTolerant)
            {
                var _ = Task.Factory.StartNew(PersistState);
            }

            if (_workflowRecordsTail == null)
            {
                _isHandlerWorkerIdle = true;
                return Task.FromResult(new Immutable<IndexWorkflowRecordNode>(null));
            }
            else
            {
                _isHandlerWorkerIdle = false;
                return Task.FromResult(AddPuctuationAt(BATCH_SIZE).AsImmutable());
            }
        }
        private bool InitHasAnyIIndex()
        {
            var indexes = IndexHandler.GetIndexes(_iGrainType);
            foreach (var idxInfo in indexes.Values)
            {
                if (idxInfo.Item1 is InitializedIndex)
                {
                    __hasAnyIIndex = 1;
                    return true;
                }
            }
            __hasAnyIIndex = -1;
            return false;
        }

        private IStorageProvider InitStorageProvider()
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// A node in the linked list of workflowRecords.
    /// 
    /// This linked list makes the traversal more efficient.
    /// </summary>
    internal class IndexWorkflowRecordNode
    {
        internal IndexWorkflowRecord WorkflowRecord;

        internal IndexWorkflowRecordNode Prev = null;
        internal IndexWorkflowRecordNode Next = null;

        /// <summary>
        /// This constructor creates a punctuation node
        /// </summary>
        public IndexWorkflowRecordNode() : this(null)
        {
        }

        public IndexWorkflowRecordNode(IndexWorkflowRecord workflow)
        {
            WorkflowRecord = workflow;
        }

        public void Append(IndexWorkflowRecordNode elem, ref IndexWorkflowRecordNode tail)
        {
            var tmpNext = Next;
            if (tmpNext != null)
            {
                elem.Next = tmpNext;
                tmpNext.Prev = elem;
            }
            elem.Prev = this;
            Next = elem;

            if (tail == this)
            {
                tail = elem;
            }
        }

        public IndexWorkflowRecordNode AppendPunctuation(ref IndexWorkflowRecordNode tail)
        {
            //we never append a punctuation to an existing punctuation.
            //It should never be requested
            if (IsPunctuation()) return null;

            var punctuation = new IndexWorkflowRecordNode();
            Append(punctuation, ref tail);
            return punctuation;
        }

        public void Remove(ref IndexWorkflowRecordNode head, ref IndexWorkflowRecordNode tail)
        {
            if (Prev == null) head = Next;
            else Prev.Next = Next;

            if (Next == null) tail = Prev;
            else Next.Prev = Prev;

            Clean();
        }

        /// <summary>
        /// This method gathers all the IndexWorkflowRecords that belong to the
        /// same grain and are continuously one after the other
        /// </summary>
        /// <returns>the continuous list of IndexWorkflowRecords for the same grain</returns>
        //public IList<IndexWorkflowRecord> GetContinousListForTheSameGrain()
        //{
        //    IList<IndexWorkflowRecord> res = new List<IndexWorkflowRecord>();
        //    res.Add(WorkflowRecord);

        //    IIndexableGrain thisGrain = WorkflowRecord.Grain;
        //    IndexWorkflowRecordNode tmp = Next;
        //    while (tmp != null && tmp.WorkflowRecord.Grain == thisGrain)
        //    {
        //        res.Add(tmp.WorkflowRecord);
        //        tmp = tmp.Next;
        //    }

        //    return res;
        //}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void Clean()
        {
            WorkflowRecord = null;
            Next = null;
            Prev = null;
        }

        internal bool IsPunctuation()
        {
            return WorkflowRecord == null;
        }
    }

    /// <summary>
    /// All the information stored for a single IndexWorkflowQueue
    /// </summary>
    internal class IndexWorkflowQueueEntry
    {
        //updates that must be propagated to indexes.
        internal IndexWorkflowRecordNode WorkflowRecordsHead;

        internal GrainId QueueId;

        internal SiloAddress Silo;

        public IndexWorkflowQueueEntry(GrainId queueId, SiloAddress silo)
        {
            WorkflowRecordsHead = null;
            QueueId = queueId;
            Silo = silo;
        }
    }

    /// <summary>
    /// The persistent unit for storing the information for a IndexWorkflowQueue
    /// </summary>
    internal class IndexWorkflowQueueState : IGrainState
    {
        public IndexWorkflowQueueEntry State;

        public IndexWorkflowQueueState(GrainId g, SiloAddress silo)
        {
            State = new IndexWorkflowQueueEntry(g, silo);
            ETag = null;
        }

        public string ETag { get; set; }

        object IGrainState.State
        {
            get
            {
                return State;
            }

            set
            {
                State = (IndexWorkflowQueueEntry) value;
            }
        }
    }
}
